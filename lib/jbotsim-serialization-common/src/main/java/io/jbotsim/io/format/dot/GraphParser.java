/*
 * Copyright 2008 - 2019, Arnaud Casteigts and the JBotSim contributors <contact@jbotsim.io>
 *
 *
 * This file is part of JBotSim.
 *
 * JBotSim is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JBotSim is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JBotSim.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

package io.jbotsim.io.format.dot;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.Pair;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;

/**
 * This class encapsulates ANTLR calls to produce a {@link DotGraph} object from parse DOT inputs.
 * a DOT input string.
 *
 * - the parsing process is based on a Visitor of the AST generated by ANTLR.
 * - default error mechanism of ANTLR is disabled and replaced by th generation
 *   of an exception with the error message.
 */
class GraphParser {

    /**
     * This method parses a stream containing a graph specified in
     * <a href="https://www.graphviz.org/doc/info/lang.html">Graphviz DOT
     * file format</a>.
     *
     * @param input the input stream
     *
     * @return the graph parsed from the given input stream
     *
     * @throws IOException in case of error while reading the input stream
     * @throws ParserException in case the input does not respected the DOT file
     *                         format.
     */
    DotGraph parseGraph(InputStream input) throws IOException {
        DotLexer lexer = new DotLexer(new ANTLRInputStream(input));
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        DotParser parser = new DotParser(tokens);
        // remove default listeners to prevent the output of error messages
        // on System.err.
        parser.removeErrorListeners();
        // add our own listener that raise ParserException on errors.
        parser.addErrorListener(new ErrorListener());

        ParseTree tree = parser.graph();

        assert (tree != null);

        DotVisitor visitor = new DotVisitor();
        return  visitor.cast_visit(tree);
    }

    /**
     * Exception raised by {@link GraphParser#parseGraph} when the input stream does not
     * respected the DOT grammar.
     */
    public static class ParserException extends RuntimeException {
        ParserException(String msg) {
            super(msg);
        }
    }

    private static class DotVisitor extends DotBaseVisitor {
        private Stack<DotGraph> stack = new Stack<>();

        DotGraph currentGraph() {
            return stack.peek();
        }

        DotGraph topGraph() {
            return stack.get(0);
        }

        <T>
        T cast_visit(ParseTree tree) {
            if (tree == null)
                return null;
            return (T) visit(tree);
        }

        @Override
        public Object visitGraph(DotParser.GraphContext ctx) {
            DotGraph dotGraph = new DotGraph();

            dotGraph.setId(cast_visit(ctx.id()));
            dotGraph.setDirected(ctx.DIGRAPH() != null);
            dotGraph.setStrict(ctx.STRICT() != null);

            stack.push(dotGraph);
            visit(ctx.stmt_list());
            assert (currentGraph() == dotGraph);
            stack.pop();
            assert (stack.isEmpty());

            return dotGraph;
        }

        @Override
        public Object visitStmt_list(DotParser.Stmt_listContext ctx) {
            return super.visitStmt_list(ctx);
        }

        @Override
        public Object visitStmt(DotParser.StmtContext ctx) {
            return super.visitStmt(ctx);
        }

        @Override
        public Object visitAttr_stmt(DotParser.Attr_stmtContext ctx) {
            AttributeTable dest;
            AttributeTable attributeTable = cast_visit(ctx.attr_list());
            DotGraph graph = currentGraph();

            if (ctx.GRAPH() != null) dest = graph;
            else if (ctx.NODE() != null) dest = graph.getNodeAttributes();
            else dest = graph.getEdgeAttributes();
            dest.putAll(attributeTable);

            return attributeTable;
        }


        @Override
        public Object visitEdge_stmt(DotParser.Edge_stmtContext ctx) {
            AttributeTable attributeTable = cast_visit(ctx.attr_list());
            List<DotParser.Node_setContext> nodes = ctx.edgeRHS().node_set();
            List<DotParser.EdgeopContext> edgeops = ctx.edgeRHS().edgeop();
            int len = edgeops.size();
            assert (nodes.size() == len);

            DotGraph graph = currentGraph();
            Set<DotNode> srcSet = cast_visit(ctx.node_set());
            for (int i = 0; i < len; i++) {
                boolean isDirected = cast_visit(edgeops.get(i));
                Set<DotNode> dstSet = cast_visit(nodes.get(i));

                for (DotNode src : srcSet) {
                    for (DotNode dst : dstSet) {
                        DotEdge edge = new DotEdge(src, dst);
                        edge.putAll(attributeTable);
                        edge.setDirected(isDirected);
                        graph.addEdge(edge);
                    }
                }
                srcSet = dstSet;
            }

            return null;
        }

        @Override
        public Object visitEdgeop(DotParser.EdgeopContext ctx) {
            return ! ctx.getText().equals("--");
        }

        @Override
        public Object visitNode_set(DotParser.Node_setContext ctx) {
            Set<DotNode> result = new HashSet<>();

            if (ctx.node_id() != null) {
                DotNode node = cast_visit(ctx.node_id());
                result.add(node);
            } else {
                DotGraph subgraph = cast_visit(ctx.subgraph());
                Set<DotNode> nodes = subgraph.getAllNodes();
                result.addAll(nodes);
            }
            return result;
        }

        @Override
        public Object visitAttr_list(DotParser.Attr_listContext ctx) {
            AttributeTable table = new AttributeTable();

            for (DotParser.A_listContext al : ctx.a_list()) {
                AttributeTable t = cast_visit(al);
                table.putAll(t);
            }

            return table;
        }

        @Override
        public Object visitA_list(DotParser.A_listContext ctx) {
            AttributeTable table = new AttributeTable();

            for (DotParser.Key_valueContext kv : ctx.key_value()) {
                Pair<String, String> key_value = cast_visit(kv);
                table.setAttribute(key_value.a, key_value.b);
            }

            return table;
        }

        @Override
        public Object visitKey_value(DotParser.Key_valueContext ctx) {
            String key = cast_visit(ctx.key);
            String value = cast_visit(ctx.value);
            if (value == null)
                value = "true";
            return new Pair<>(key, value);
        }

        @Override
        public Object visitNode_stmt(DotParser.Node_stmtContext ctx) {
            DotNode node = cast_visit(ctx.node_id());
            AttributeTable attrList = cast_visit(ctx.attr_list());
            node.putAll(attrList);

            return node;
        }

        @Override
        public Object visitNode_id(DotParser.Node_idContext ctx) {
            String id = cast_visit(ctx.id());
            DotNode node = topGraph().getNode(id);
            if (node == null) {
                node = new DotNode(id);
                currentGraph().addNode(node);
            }
            return node;
        }

        @Override
        public Object visitSubgraph(DotParser.SubgraphContext ctx) {
            DotGraph subgraph = new DotGraph();

            subgraph.setId(cast_visit(ctx.id()));
            subgraph.setDirected(topGraph().isDirected());
            currentGraph().addSubGraph(subgraph);

            stack.push(subgraph);
            visit(ctx.stmt_list());
            assert (currentGraph() == subgraph);
            stack.pop();

            return subgraph;
        }

        @Override
        public Object visitId(DotParser.IdContext ctx) {
            TerminalNode node = ctx.ID();
            if (node == null) node = ctx.HTML_STRING();
            if (node == null) node = ctx.STRING();
            if (node == null) node = ctx.NUMBER();
            assert (node != null);
            String result = node.getText();
            if (ctx.STRING() != null) {
                int len = result.length();
                if (len >= 2 && result.charAt(0) == '"' &&
                        result.charAt(len - 1) == '"') {
                    result = result.substring(1, len - 1);
                }
                result = result.replace("\\\"", "\"");
            }
            return result;
        }
    }

    private static class ErrorListener extends BaseErrorListener {
        @Override
        public void syntaxError(Recognizer<?, ?> recognizer,
                                Object offendingSymbol, int line,
                                int charPositionInLine, String msg,
                                RecognitionException e) {
            String message = "error:" + line + ":" + charPositionInLine + ": " + msg;

            throw new ParserException(message);
        }
    }
}
